{"version":3,"sources":["../../../src/internal-plugins/webpack-theme-component-shadowing/index.js"],"names":["path","require","debug","fs","_","pathWithoutExtension","fullPath","parsed","parse","join","dir","name","module","exports","GatsbyThemeComponentShadowingResolverPlugin","constructor","projectRoot","themes","map","themeName","apply","resolver","plugin","request","callback","matchingThemes","getMatchingThemesForPath","length","Error","theme","split","component","context","issuer","requestPathIsIssuerShadowPath","requestPath","issuerPath","doResolve","builtComponentPath","resolveComponentPath","matchingTheme","ogThemes","filter","cache","resolve","concat","Array","from","reverse","themeDir","find","possibleComponentPath","readdirSync","dirname","e","exists","filepath","ext","extname","filenameWithoutExtension","basename","includes","allMatchingThemes","uniq","getBaseShadowDirsForThemes","shadowFiles"],"mappings":"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","sourcesContent":["const path = require(`path`)\nconst debug = require(`debug`)(`gatsby:component-shadowing`)\nconst fs = require(`fs`)\nconst _ = require(`lodash`)\n\nconst pathWithoutExtension = fullPath => {\n  const parsed = path.parse(fullPath)\n  return path.join(parsed.dir, parsed.name)\n}\n\nmodule.exports = class GatsbyThemeComponentShadowingResolverPlugin {\n  cache = {}\n\n  constructor({ projectRoot, themes }) {\n    debug(`themes list`, themes.map(({ themeName }) => themeName))\n    this.themes = themes\n    this.projectRoot = projectRoot\n  }\n\n  apply(resolver) {\n    resolver.plugin(`relative`, (request, callback) => {\n      const matchingThemes = this.getMatchingThemesForPath(request.path)\n\n      // 0 matching themes happens a lot for paths we don't want to handle\n      // > 1 matching theme means we have a path like\n      //   `gatsby-theme-blog/src/components/gatsby-theme-something/src/components`\n      if (matchingThemes.length > 1) {\n        throw new Error(\n          `Gatsby can't differentiate between themes ${matchingThemes.join(\n            ` and `\n          )} for path ${request.path}`\n        )\n      }\n\n      if (matchingThemes.length !== 1) {\n        return callback()\n      }\n\n      // theme is the theme package from which we're requiring the relative component\n      const [theme] = matchingThemes\n      // get the location of the component relative to src/\n      const [, component] = request.path.split(path.join(theme, `src`))\n\n      if (\n        /**\n         * if someone adds\n         * ```\n         * modules: [path.resolve(__dirname, 'src'), 'node_modules'],\n         * ```\n         * to the webpack config, `issuer` is `null`, so we skip this check.\n         * note that it's probably a bad idea in general to set `modules`\n         * like this in a theme, but we also shouldn't artificially break\n         * people that do.\n         */\n        request.context.issuer &&\n        /**\n         * An issuer is the file making the require request. It can\n         * be in a user's site or a theme. If the issuer is requesting\n         * a path in the shadow chain that it participates in, then we\n         * will let the request through as normal. Otherwise, we\n         * engage the shadowing algorithm.\n         */\n        this.requestPathIsIssuerShadowPath({\n          requestPath: request.path,\n          issuerPath: request.context.issuer,\n        })\n      ) {\n        return resolver.doResolve(\n          `describedRelative`,\n          request,\n          null,\n          {},\n          callback\n        )\n      }\n\n      // This is the shadowing algorithm.\n      const builtComponentPath = this.resolveComponentPath({\n        matchingTheme: theme,\n        themes: this.themes,\n        component,\n      })\n\n      return resolver.doResolve(\n        `describedRelative`,\n        { ...request, path: builtComponentPath || request.path },\n        null,\n        {},\n        callback\n      )\n    })\n  }\n\n  // check the cache, the user's project, and finally the theme files\n  resolveComponentPath({ matchingTheme: theme, themes: ogThemes, component }) {\n    // don't include matching theme in possible shadowing paths\n    const themes = ogThemes.filter(({ themeName }) => themeName !== theme)\n    if (!this.cache[`${theme}-${component}`]) {\n      this.cache[`${theme}-${component}`] = [\n        path.join(path.resolve(`.`), `src`, theme),\n      ]\n        .concat(\n          Array.from(themes)\n            .reverse()\n            .map(({ themeDir }) => path.join(themeDir, `src`, theme))\n        )\n        .map(dir => path.join(dir, component))\n        .find(possibleComponentPath => {\n          debug(`possibleComponentPath`, possibleComponentPath)\n          let dir\n          try {\n            // we use fs/path instead of require.resolve to work with\n            // TypeScript and alternate syntaxes\n            dir = fs.readdirSync(path.dirname(possibleComponentPath))\n          } catch (e) {\n            return false\n          }\n          const exists = dir\n            .map(filepath => {\n              const ext = path.extname(filepath)\n              const filenameWithoutExtension = path.basename(filepath, ext)\n              return filenameWithoutExtension\n            })\n            .includes(\n              path.basename(\n                possibleComponentPath,\n                path.extname(possibleComponentPath)\n              )\n            )\n          return exists\n        })\n    }\n\n    return this.cache[`${theme}-${component}`]\n  }\n\n  getMatchingThemesForPath(filepath) {\n    // find out which theme's src/components dir we're requiring from\n    const allMatchingThemes = this.themes.filter(({ themeName }) =>\n      filepath.includes(path.join(themeName, `src`))\n    )\n\n    // The same theme can be included twice in the themes list causing multiple\n    // matches. This case should only be counted as a single match for that theme.\n    return _.uniq(allMatchingThemes.map(({ themeName }) => themeName))\n  }\n\n  // given a theme name, return all of the possible shadow locations\n  getBaseShadowDirsForThemes(theme) {\n    return Array.from(this.themes)\n      .reverse()\n      .map(({ themeName, themeDir }) => {\n        if (themeName === theme) {\n          return path.join(themeDir, `src`)\n        } else {\n          return path.join(themeDir, `src`, theme)\n        }\n      })\n  }\n\n  requestPathIsIssuerShadowPath({ requestPath, issuerPath }) {\n    // get the issuer's theme\n    const matchingThemes = this.getMatchingThemesForPath(requestPath)\n    if (matchingThemes.length !== 1) {\n      return false\n    }\n    const [theme] = matchingThemes\n\n    // get the location of the component relative to src/\n    const [, component] = requestPath.split(path.join(theme, `src`))\n\n    // get list of potential shadow locations\n    const shadowFiles = this.getBaseShadowDirsForThemes(theme).map(dir =>\n      path.join(dir, component)\n    )\n\n    // if the issuer is requesting a path that is a potential shadow path of itself\n    return shadowFiles.includes(pathWithoutExtension(issuerPath))\n  }\n}\n"],"file":"index.js"}