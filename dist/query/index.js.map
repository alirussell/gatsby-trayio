{"version":3,"sources":["../../src/query/index.js"],"names":["_","require","convertHrtime","store","emitter","queryQueue","jobHandler","seenIdsWithoutDataDependencies","queuedDirtyActions","extractedQueryIds","Set","on","action","filter","p","payload","path","push","enqueueExtractedQueryId","queryId","add","findIdsWithoutDataDependencies","state","allTrackedIds","uniq","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","Array","from","pages","staticQueryComponents","map","c","id","popNodeQueries","actions","a","uniqDirties","reduce","dirtyIds","node","internal","type","compact","popNodeAndDepQueries","nodeQueries","noDepQueries","popExtractedQueries","queries","clear","calcDirtyQueryIds","union","calcBootstrapDirtyQueryIds","nodeAndNoDepQueries","extractedQueriesThatNeedRunning","intersection","groupQueryIds","queryIds","grouped","groupBy","slice","staticQueryIds","pageQueryIds","processQueries","queryJobs","activity","length","startQueries","process","hrtime","queue","create","stats","getStats","setStatus","total","peak","seconds","toFixed","drainedPromise","Promise","resolve","once","forEach","queryJob","makePageQueryJob","page","get","component","components","componentPath","context","query","isPage","processPageQueries","getState","makeStaticQueryJob","hash","processStaticQueries","startListener","runQueuedActions","dirtyQueryIds","runQueries","emit","module","exports","createQueue"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst convertHrtime = require(`convert-hrtime`)\nconst { store, emitter } = require(`../redux`)\nconst queryQueue = require(`./query-queue`)\nconst jobHandler = require(`./job-handler`)\n\nlet seenIdsWithoutDataDependencies = []\nlet queuedDirtyActions = []\nconst extractedQueryIds = new Set()\n\n// Remove pages from seenIdsWithoutDataDependencies when they're deleted\n// so their query will be run again if they're created again.\nemitter.on(`DELETE_PAGE`, action => {\n  seenIdsWithoutDataDependencies = seenIdsWithoutDataDependencies.filter(\n    p => p !== action.payload.path\n  )\n})\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\nconst enqueueExtractedQueryId = queryId => {\n  extractedQueryIds.add(queryId)\n}\n\n/////////////////////////////////////////////////////////////////////\n// Calculate dirty static/page queries\n\nconst findIdsWithoutDataDependencies = state => {\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...Array.from(state.pages.values(), p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.id),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst popNodeQueries = ({ state }) => {\n  const actions = _.uniq(queuedDirtyActions, a => a.payload.id)\n\n  const uniqDirties = _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find components that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n  queuedDirtyActions = []\n  return uniqDirties\n}\n\nconst popNodeAndDepQueries = state => {\n  const nodeQueries = popNodeQueries({ state })\n\n  const noDepQueries = findIdsWithoutDataDependencies(state)\n\n  return _.uniq([...nodeQueries, ...noDepQueries])\n}\n\nconst popExtractedQueries = () => {\n  const queries = [...extractedQueryIds]\n  extractedQueryIds.clear()\n  return queries\n}\n\n/**\n * Calculates the set of dirty query IDs (page.paths, or\n * staticQuery.hash's). These are queries that:\n *\n * - depend on nodes or node collections (via\n *   `actions.createPageDependency`) that have changed.\n * - do NOT have node dependencies. Since all queries should return\n *   data, then this implies that node dependencies have not been\n *   tracked, and therefore these queries haven't been run before\n * - have been recently extracted (see `./query-watcher.js`)\n *\n * Note, this function pops queries off internal queues, so it's up\n * to the caller to reference the results\n */\n\nconst calcDirtyQueryIds = state =>\n  _.union(popNodeAndDepQueries(state), popExtractedQueries())\n\n/**\n * Same as `calcDirtyQueryIds`, except that we only include extracted\n * queries that depend on nodes or haven't been run yet. We do this\n * because the page component reducer/machine always enqueues\n * extractedQueryIds but during bootstrap we may not want to run those\n * page queries if their data hasn't changed since the last time we\n * ran Gatsby.\n */\nconst calcBootstrapDirtyQueryIds = state => {\n  const nodeAndNoDepQueries = popNodeAndDepQueries(state)\n\n  const extractedQueriesThatNeedRunning = _.intersection(\n    popExtractedQueries(),\n    nodeAndNoDepQueries\n  )\n  return _.union(extractedQueriesThatNeedRunning, nodeAndNoDepQueries)\n}\n\n/**\n * groups queryIds by whether they are static or page queries.\n */\nconst groupQueryIds = queryIds => {\n  const grouped = _.groupBy(queryIds, p => p.slice(0, 4) === `sq--`)\n  return {\n    staticQueryIds: grouped[true] || [],\n    pageQueryIds: grouped[false] || [],\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Create Query Jobs\n\nconst processQueries = async (queryJobs, { activity }) => {\n  if (queryJobs.length == 0) {\n    return\n  }\n  const startQueries = process.hrtime()\n\n  const queue = queryQueue.create()\n  queue.on(`task_finish`, () => {\n    const stats = queue.getStats()\n    if (activity) {\n      activity.setStatus(\n        `${stats.total}/${stats.peak} ${(\n          stats.total / convertHrtime(process.hrtime(startQueries)).seconds\n        ).toFixed(2)} queries/second`\n      )\n    }\n  })\n  const drainedPromise = new Promise(resolve => {\n    queue.once(`drain`, resolve)\n  })\n\n  queryJobs.forEach(queryJob => {\n    queue.push(queryJob)\n  })\n  await drainedPromise\n}\n\nconst makePageQueryJob = (state, queryId) => {\n  const page = state.pages.get(queryId)\n  const component = state.components.get(page.componentPath)\n  const { path, componentPath, context } = page\n  const { query } = component\n  return {\n    id: path,\n    query,\n    isPage: true,\n    componentPath,\n    context: {\n      ...page,\n      ...context,\n    },\n  }\n}\n\nconst processPageQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  await processQueries(queryIds.map(id => makePageQueryJob(state, id)), {\n    activity,\n  })\n}\n\nconst makeStaticQueryJob = (state, queryId) => {\n  const component = state.staticQueryComponents.get(queryId)\n  const { hash, id, query, componentPath } = component\n  return {\n    id,\n    hash,\n    query,\n    componentPath,\n    context: { path: id },\n  }\n}\n\nconst processStaticQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  await processQueries(queryIds.map(id => makeStaticQueryJob(state, id)), {\n    activity,\n  })\n}\n\n/////////////////////////////////////////////////////////////////////\n// Background query daemon (for gatsby develop)\n\n/**\n * Starts a background process that processes any dirty queries\n * whenever one of the following occurs.\n *\n * 1. A node has changed (but only after the api call has finished\n * running)\n * 2. A component query (e.g by editing a React Component) has\n * changed\n *\n * For what constitutes a dirty query, see `calcDirtyQueryIds`\n */\nconst startListener = queue => {\n  const runQueuedActions = () => {\n    const state = store.getState()\n\n    const dirtyQueryIds = calcDirtyQueryIds(state)\n    const { staticQueryIds, pageQueryIds } = groupQueryIds(dirtyQueryIds)\n\n    staticQueryIds\n      .map(id => makeStaticQueryJob(state, id))\n      .forEach(queryJob => {\n        queue.push(queryJob)\n      })\n\n    pageQueryIds\n      .map(id => makePageQueryJob(state, id))\n      .forEach(queryJob => {\n        queue.push(queryJob)\n      })\n  }\n  runQueuedActions()\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n  emitter.on(`QUERY_RUNNER_QUERIES_ENQUEUED`, runQueuedActions)\n}\n\n/**\n * Force query processing to run. Noop until `startDaemon` has been\n * called.\n */\nconst runQueries = () => {\n  // A bit hacky bit it works well.\n  emitter.emit(`QUERY_RUNNER_QUERIES_ENQUEUED`)\n}\n\nmodule.exports = {\n  enqueueExtractedQueryId,\n  calcBootstrapDirtyQueryIds,\n  groupQueryIds,\n  processQueries,\n  processPageQueries,\n  processStaticQueries,\n  runQueries,\n  startListener,\n  createQueue: queryQueue.create,\n  jobHandler,\n}\n"],"file":"index.js"}